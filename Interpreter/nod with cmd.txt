.data
maxDiv 1 // Инициализированная переменная minDiv = 1
n1 20 // Неинициализированная переменная n1
n2 15 // Неинициализированная переменная n2
exc 1 // В счётчике ecx сохраняем 1

.code
for_start // Начало цикла
    mov eax n1 // В eax сохраняем n1
    mov ebx n2 // В ebx сохраняем n2
    mov emx n1 // В emx сохраняем n1
    min emx ebx // В emx сохраняем минимум из emx и ebx
    mod eax ecx // Получается остаток от деления
    mod ebx ecx // Получается остаток от деления
    start_if // Проверка
        and eax ebx // Логическая операция И
        cmp eax 0 // Сравнение eax с нулём
        jne end_if // Если eax и 0 не равны - выходим из begin_if
        mov maxDiv ecx // В maxDiv сохраняем счётчик
    end_if // Конец проверка
    add ecx 1 // +1 к счётчику
    cmp emx ecx // Если счётчик равен минимуму из двух чисел, то след. строка
    jge for_end // Переход, если больше или равно - завершаем цикл
for_end // Конец цикла

output maxDiv // Вывод на консоль
end // Конец программы
-----------------------------------------------
.code
// #2 - Первое число
// #3 - Второе число
input #2
input #3
// #4 - Первое число (Для минимального числа) - emx
// #5 - Второе число (Для большого числа) - ebx
mov #4 #2
mov #5 #3

// Сравнение #5 и #4, если #5 >= #4, то идёт переход, иначе замена
cmp #5 #4
jge :for_start

:start_chooseNumber
// #6 - Временная ячейка для хранения #5 (Большое число)
mov #6 #5
mov #5 #4
mov #4 #6

:for_start
    // Проверка, если второе число >= первого числа, то 
    cmp #4 #5
    jge :start_chooseNumber
    diff #7 #5 #4
    cmp #7 0
    je :for_end
    mul #7 -1
    mov #5 #7
    jmp :for_start
:for_end

// Вывод результата
output #5
// Выход из программы
end